
# [Platinum II] 나무 자르기 - 13263

[문제 링크](https://www.acmicpc.net/problem/13263)

### 문제 요약

<p> Do you know CHW? </p>

### 제한

TL : 2sec, ML : 512 MB

$1 ≤ n ≤ 100,000$

$1 ≤ a_i ≤ 10^9$

$0 ≤ b_i ≤ 10^9$

### 성능 요약

메모리: 6708 KB, 시간: 28 ms

### 분류

다이나믹 프로그래밍(dp), 볼록 껍질을 이용한 최적화 (Convex Hull Optimization)

### comment

오늘 드디어 궁금했던 'Convex Hull Optimization'을 공부해 보았다.

[이 글](https://koosaga.com/242)과 [이 글](https://m.blog.naver.com/kks227/221418495037)에서 주로 공부했다.

역시나 처음 적용은 cht계의 대표 예제인 이 문제였다.

cht에 대한 좋은 글들은 윗 글들을 포함한 많은 글들이 이미 있으므로 바로 문제로 넘어가겠다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

우선 가장 나이브한 풀이를 생각해보자.

문제의 조건에 따르면

* $a_1 = 1, b_n = 0$
* $a_1 < a_2 < ... < a_n, b_1 > b_2 > ... > b_n$

이 만족된다.

$dp[i]$ : $i$번 나무를 높이 1로 만드는 데 드는 최소 비용이라고 할 때

$0 ≤ j < i$에서 $dp[i] = min(dp[i], a[i] * b[j] + dp[j]);$

라고 할 수 있다.

즉, 위 식을 $i > 0$인 모든 지점에서 돌려주면 $O(N^2)$으로 문제를 해결할 수 있다.

만약 이게 정해였다면 이 문제는 단순 실버급 dp예제였을 듯.

하지만 $1 ≤ n ≤ 100,000$ 로 $O(N^2)$의 풀이론 어림도 없음을 알 수 있다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

각 시점에서 우리가 구해야 하는 값은 $0 ≤ j < i$ 을 만족하는 $min(b[j] * a[i] + dp[j])$ 의 값을 찾는 것이다.

이때 위의 형태를 직선의 방정식으로 생각해보자.

$a[i] = x$라 하면 $min(b[j] * x + dp[j])$

즉, 각 $j$에 대한 일차 함수 $f(x) = b(j) * x + C$ 로 표현해낼 수 있다. ( $C$는 상수 혹은 $Δj$와 관련이 없는 값)

여기서 cht를 적용하기 위한 중요한 사실은 $b[j]$가 항상 **단조 감소** 한다는 것이다.

결국 위에서의 문제는 임의의 위치 $i$에서 $i - 1$개의 $f_j(x)$ 함수에 대해 $min(f(a[i]))$ 를 찾는 것이라고 할 수 있다.

그런데 위에서 말했듯 $j$가 증가함에 따라 $b[j]$는 **단조 감소** 한다.

이에 따라 굳이 $i - 1$개의 함수를 다 보지 않아도 이분 탐색을 이용해 각 $i$에서의 dp값을 $O(logN)$만에 계산해낼 수 있게 된다.

최종적으로 $O(N^2) -> O(N * logN)$ 의 최적화를 통해 문제를 풀수 있다.
