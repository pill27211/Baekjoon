# [Platinum II] 서로 다른 수와 쿼리 1 - 14897

[문제 링크](https://www.acmicpc.net/problem/14897)

### 문제 요약

<p> 길이가 N인 수열이 주어진다. 이에 구간 단위 서로 다른 수의 개수를 세는 Q개의 쿼리를 처리해보자. </p>

### 제한

TL : 5sec, ML : 1024 MB

1 ≤ N, Q ≤ 1,000,000

1 ≤ i ≤ 1,000,000,000

1 ≤ l ≤ r ≤ N

### 성능 요약

메모리: 33292 KB, 시간: 4704 ms

### 분류

자료 구조(data structure), 세그먼트 트리(segtree), 머지 소트 트리(merge sort tree), 오프라인 쿼리(offline query),

값 / 좌표 압축(coordinate_compression), mo's(mo's algorithm)

### comment

최근 업데이트가 없는 쿼리 문제들을 mo's로 여럿 풀어봐서 그런지 이제 이런 문제를 보면 우선 가장 먼저 mo's가 떠오른다.

사실 이 문제는 mo's 이외에 세그먼트 트리, 머지소트 트리 등 다양한 풀이가 있고 mo's보다 더 빠른 속도로 문제를 해결할 수 있다.

하지만 처음 떠오른 mo's로 풀이해보자. (주의 : N과 Q의 범위가 꽤 빡빡함)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

우선 수열 내 요소들의 범위는 1 ≤ i ≤ 1,000,000,000이다. 당연히 좌표 압축을 진행해주자.

쿼리들또한 Q.s / sqrt(n) 단위로 순서를 정렬해주고, 0번째 쿼리를 전처리 해준 뒤 1 ~ n - 1개의 쿼리들에 대해 결과를 쭉쭉 뽑아내보자.

구간 내 서로 다른 수의 개수를 세기 위해 따로 카운트 배열을 만들었고, 다음과 같이 카운트 규칙을 세웠다.

. 어떤 새로운 구간의 수를 직면할 때(= 더할 때), 해당 수의 카운트 수를 증가시킨 뒤 증가된 카운트 수가 1이라면(= 해당 수가 처음 보는 수라면) -> 서로 다른 수의 개수 ++

. 현재 포함하고 있는 어떤 구간의 수를 버릴 때(= 뺄 때), 해당 수의 카운트 수를 카운트 수를 감소시킨 뒤 감소된 카운트 수가 0이라면(= 해당 수를 이제 갖고 있지 않게 된다면) -> 서로 다른 수의 개수 --

위 규칙 이외의 상황이라면 해당 수의 카운트 수가 증가되던 감소되던 이미 1개 이상의 해당 수가 지금 포함하고 있는 구간에 있다는 뜻이므로 서로 다른 수의 개수엔 변화가 없다.

이 규칙에 기반해 각 쿼리들의 결과를 찾아주면 된다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

약 4.7초로 5초컷에 대해 아슬아슬하게 통과하길래 채점 현황을 둘러보니 mo's 를 이용한 코드는 대부분 4.5 ~ 정도였으며, 이 정도의 빡빡함이면 동일한 코드 그대로 제출해도 정말 운 안좋으면 TLE를 얻어맞을 수도 있다.

이참에 고인물들의 테크닉인 pragma, register 등의 최적화를 찾아볼까하는 생각이 들었다.
