# [Platinum III] 어지러운 트리 - 25973

[문제 링크](https://www.acmicpc.net/problem/25973)

### 문제 요약

<p> $N$개의 정점으로 이루어진 트리와 두 종류로 이루어진 $Q$개의 쿼리가 주어진다. $2$번 쿼리가 주어질 때마다 그에 맞는 답을 출력하자. </p>

### 제한

TL : 1sec, ML : 1024 MB

$1 ≤ N, Q ≤ 200,000$

### 성능 요약

메모리: 32892 KB, 시간: 236 ms

### 분류

트리(trees), 최소 공통 조상(lowest ancestor common), 다이나믹 프로그래밍(dp), 트리에서의 다이나믹 프로그래밍(dp_tree)

### comment

간만에 재밌는 트리 문제를 풀었다.

주어지는 쿼리는 다음과 같다.

* $1$ $x$ : 루트 노드를 $x$번 노드로 변경한다.
* $2$ $x$ : $LCA(a, b) = x$번 노드인 $(a, b)$의 쌍으로 가능한 경우의 수를 출력한다. $(a, b)$와 $(b, a)$는 같은 순서쌍으로 생각한다. $(a ≠ b)$ 

제한을 보면 매 쿼리마다 트리에 dfs를 돌리며 경우의 수를 계산할 순 없는 노릇이다.

루트가 1인 최초 시점을 기준으로 모든 경우의 수를 전처리 후 $x$와 현재 루트 정점을 가지고 뭐 어떻게 잘 요리해서 쿼리당 $O(logN)$으로 응답할 것을 생각하자.

즉, $LCA$를 찾는 시간을 제외하면 상수 시간에 계산을 마쳐보자.

경우의 수는 서브 트리에 사이즈 $(S[])$ 로써 계산되니 $LCA$를 위한 전처리를 하며 임의의 정점에 대한 경우의 수 전처리도 동시에 해주자.

$Sdp[i]$ : 루트가 1인 시점을 기준으로 $x$ $==$ $i$ 일 때 $(a, b)$의 쌍으로 가능한 경우의 수.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

1번 쿼리는 간단하다. 말그대로 현재 루트 노드 $(o)$ 를 $x$로 교체해준다.

2번 쿼리는 크게 3가지로 나누어 생각해보자.

$1.$ $x$ $==$ $o$일 때.

$2.$ $LCA(x, o)$ $==$ $x$일 때.

$3.$ $x$와 $o$가 아무런 연고가 없을 때.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

$1$의 경우

루트가 $1$이었다면 참 좋겠지만 그렇지 않은 경우로 우리를 공격할테니 일반화를 해야 한다.

#### 아래 내용에서의 $S[]$, $Sdp[]$는 루트가 1일 때를 기준으로 전처리 한 것이다. 이를 항상 명심하여 식을 세워보자.

일단 당연히 포함 되는 값은, $Sdp[x]$와 $S[x]$ $-$ $1$ 이다. ( 후자는 $x$와 그 서브 트리 내 노드를 고르는 경우의 수 )

그리고 $x$가 루트가 되면서 반전 되는 경우의 수를 더해줘야 한다.

이는 위에서의 $S[x]$ $-$ $1$와 나머지 노드들인 $N$ $-$ $S[x])$ 를 곱한 값과 $N$ $-$ $S[x]$ 를 더해주면 된다.

소거할 항을 소거하고 식을 정리해 보면

$A_i = Sdp[x] + S[x] - 1 + (S[x] - 1) * (N - S[x]) + N - S[x]$

$A_i = Sdp[x] + S[x] - 1 + NS[x] - S[x]^2 - N + S[x] + N - S[i]$

$A_i = Sdp[x] - 1 - S[x] * (S[x] - N - 1)$

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

$2$의 경우

가장 까다로운 경우이다. 포함 및 배제할 값들을 정확히 추리기 위해 $o$를 $x$ 바로 밑까지 끌어올려 주고, 이 노드를 $y$라 하자.

우선 당연히 포함 되는 값은, $Sdp[x]$와 $N - S[y] - 1$ 가 된다. ( 후자는 $x$와 바뀐 서브 트리 내 노드를 고르는 경우의 수 )

그리고 $x$의 $S[y]$를 제외한 기존 하위 노드들과 새로이 $x$의 하위 노드가 된 노드들간의 경우의 수를 더해줘야 한다.

$(S[x] - S[y] - 1) * (N - S[x])$

또한 위의 $Sdp[x]$는 $S[y]$의 노드들이 고려된 값이다. 관계가 뒤집힘에 따라 발생하는 차이만큼 빼주어야 하므로

$- S[y] * (S[x] - S[y] - 1)$ 를 빼주면 된다.

소거할 항을 소거하고 식을 정리해 보면

$A_i = Sdp[x] + N - S[y] - 1 + (S[x] - S[y] - 1) * (N - S[x]) - S[y] * (S[x] - S[y] - 1)$

$A_i = Sdp[x] + N - S[y] - 1 + NS[x] - S[x]^2 - NS[y] + S[y]S[x] - N + S[x] - S[y]S[x] + S[y]^2 + S[y]$

$A_i = Sdp[x] - 1 + S[y] * (S[y] - N) - S[x] * (S[x] - N - 1);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

$3$의 경우

굉장히 간단하다.

루트가 어떤 노드이건 상관 없이 $x$와 $x$의 서브 트리로만 구성된다.

$A_i = Sdp[x] + S[x] - 1$

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

위의 과정이 써있긴 하지만 적당한 사이즈의 트리를 만들어 놓고 이런저런 예제를 만들어 보며 직접 식을 유도해 보는 것을 추천한다.

$LCA$와 친해질 수 있는 좋은 문제라고 생각.
