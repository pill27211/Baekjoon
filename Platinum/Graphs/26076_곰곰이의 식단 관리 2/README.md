
# [Platinum V] 곰곰이의 식단 관리 2 - 26076

[문제 링크](https://www.acmicpc.net/problem/26076)

### 문제 요약

<p> 2차원 맵이 주어지고, (1, 1)에서 (n, m)으로 가지 못하게 벽을 세워야 한다. 최소 몇 개의 벽을 설치해야 가지 못하게 할 수 있을까? </p>

### 제한

TL : 3.5sec, ML : 1024 MB

1 ≤ n, m ≤ 2,000

(1, 1)과 (n, m)에는 장애물이 없음이 보장된다.

### 성능 요약

메모리: 21784 KB, 시간: 412 ms

### 분류

그래프 이론(graphs), 그래프 탐색(graph_traversal), 애드 혹(ad_hoc), 너비 우선 탐색(bfs), 다익스트라(dijkstra), 0_1 너비 우선 탐색(0_1_bfs)

### comment

상당히 재밌는 관찰을 요구하는 문제이다.

먼저 상하좌우 bfs의 특성을 고려해 최악, 최선의 경우를 살펴보자.

* 최악 : 사실상 4방향 이동만이 가능하며 (1, 1)에서 시작한다. 즉, 아무리 뻥 뚫려 있어도 (1, 2), (2, 1)을 막아 버리면 된다는 것.
* 최선 : 이미 막혀 있다면 굳이 벽을 세울 필요가 없지 않을까?

이에 따라 낼 수 있는 결론은 다음과 같다.

* 답은 0, 1, 2 중 하나이다.
* 0인 경우는 일단 (1, 1)에서 bfs를 돌려보면 알 수 있다.
* 그럼 이제 1, 2를 구분해야 하는데.. 어떤 논리가 필요할까?

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

맵을 ((1, 1), (n, m)을 관통하는) 대각선으로 짤라보자.

그럼 직사각형의 맵은 (S1 = 왼 쪽 변, 아래 쪽 변) : (S2 = 위 쪽 변, 오른 쪽 변) 과 같이 나눌 수 있다.

4개의 테두리를 둘러보며 각 테두리로부터 뻗어 나오는 벽에 대해 새로운 번호를 부여하자.(S1, S2를 구분하기 위해 S1과 이어진 벽은 2, S2와 이어진 벽은 3으로 부여)

이때는 상하좌우 뿐만 아니라 대각선으로도 뻗어 나가야 한다.(대각선으로 이어진 벽또한 그 부분을 지날 수 없게 되므로)

그럼 결국 맵의 각 칸에는 0, 1, 2, 3 중 하나가 표시되어 있게 된다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

이제 0이 표시된 영역에 벽을 세울 수 있는데.. 0이 표시된 임의의 영역(x)에 대해 다음을 생각해보자.

* x를 기준으로 주위 8가지의 방향에 2, 3으로 표시된 영역이 각각 하나 이상 존재한다.

참고로 앞서 말했듯이 2, 3으로 표시된 영역은 **각 테두리에서 끊이지 않고 이어진 부분** 이다.

이것에서 알 수 있는 건 무엇일까?

그렇다. x에 벽을 세우면 (1, 1)에서 (n, m)으로 도달할 수 없게됨을 의미한다.

이것을 모든 곳을 돌아보며 확인해 보면 된다.

만약 어떠한 곳에서도 이것을 만족하지 않는다면, 1개의 벽만으로는 막을 수 없다는 것이므로 답은 2가 되겠다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

한가지 까다로운 예외가 남았는데, 바로 x가 테두리에 해당하는 경우이다.

이는 S1 테두리의 경우 주위 3인 곳이 있으면 되고, S2 테두리의 경우 주위 2인 곳이 있으면 된다.

x가 테두리일 때마다 이것을 체크해주도록 하자.

진짜 마지막으로, 행(n) 또는 열(m)이 1인 경우를 놓치지 않는지 꼭 확인해보자.
