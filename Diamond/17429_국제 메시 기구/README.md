# [Diamond IV] 국제 메시 기구 - 17429

[문제 링크](https://www.acmicpc.net/problem/17429)

### 문제 요약

<p>트리가 주어지면, 6가지의 쿼리를 적절히 처리해보자. (단, 출력에 있어서 2^32로 나눈 나머지를 출력해야 한다.)</p>

### 제한

TL : 3sec, ML : 1024 MB

1 ≤ N ≤ 500,000

1 ≤ Q ≤ 100,000

{0 || 1 } ≤ update value ≤ 10^9

### 성능 요약

메모리: 127500 KB, 시간: 1148 ms

### 분류

자료구조(data_structures), 트리(trees), 세그먼트 트리(segtree), 느리게 갱신되는 세그먼트 트리(lazyprop)

오일러 투어 테크닉(euler_tour_technique), heavy-light 분할(heavy-light decomposition)


### comment

처음 보자마자 [이 문제](https://www.acmicpc.net/problem/13925)가 생각 났다. (단지 트리 위에서 진행되기 때문에 HLD가 필요했고, 쿼리 종류도 많아 구현량이 적지 않았음)

한가지 출제자분의 배려(?)인지는 모르겠으나 출력에 있어서 항상 2^32로 나눈 나머지를 출력해야 한다는 것이다.

바꿔 말하면 long long, unsigned long long 등을 사용하며 모듈러 연산에 스트레스 받을 필요 없이 역으로 unsigned int 자료형을 사용하면, 모듈러 연산을 아예 할 필요가 없게 된다.

수쿼 13처럼 세그먼트 트리는 합세그로 구성하며, lazy에서 두 개의 값을 관리하자. 각각 곱해지는 값, 더해지는 값에 해당하며 seg[i] = a * x + b의 형태로 값을 관리해주면 된다.

수쿼 13과 달리 모듈러 연산을 신경 쓸 필요가 없어서 업데이트 관리는 더 편하게 느껴질 수도 있을 것 같다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

1번 쿼리.

 : X의 서브 트리에만 업데이트가 적용되므로 in[X] 부터 out[X]까지에 대해 업데이트 쿼리를 날리면 된다.
 
2번 쿼리.

 : 정점 X부터 정점 Y로의 경로에 대해 업데이트가 적용되므로 X, Y가 같은 체인에 속할 때 까지 깊이가 낮은 체인부터 업데이트 쿼리를 날리며 끌어 올려준다. 이후 in[X]부터 in[Y]에 최종적으로 쿼리를 날려주면 된다.
 
3번 쿼리.

 : 1번 쿼리의 동작과 같다.
 
4번 쿼리.

 : 2번 쿼리의 동작과 같다.
 
5번 쿼리.

 : 1번 쿼리의 동작과 같으며, 정점 X의 서브 트리에 합쿼리를 날리면 된다.
 
6번 쿼리.

 : 2번 쿼리의 동작과 같으며, 정점 X부터 정점 Y까지의 경로에 대해 합쿼리를 날리면 된다.
