
# [Diamond IV] 안전한 비상연락망 - 10169

[문제 링크](https://www.acmicpc.net/problem/10169)

### 문제 요약

<p> 입력된 간선들을 순서대로 순회하며 i번째 간선을 포함하지 않을 때의 mst를 구해보자. </p>

### 제한

TL : 1sec, ML : 64 MB

2 ≤ N ≤ 100,000

2 ≤ M ≤ 300,000

1 ≤ E.w ≤ 1,000,000,000

하나의 마을 쌍에 대해 여러 개의 도로가 존재할 수도 있으며, 서로 다른 도로가 같은 비용 값을 가질 수도 있다.

### 성능 요약

메모리: 38000 KB, 시간: 304 ms

### 분류

자료구조(data structure), 그래프 이론(graphs), 트리(trees), 세그먼트 트리(segtree), 느리게 갱신되는 세그먼트 트리(lazyprop), heavy-light 분할(heavy-light decomposition), 
최소 스패닝 트리(minimum spanning tree), 최소 공통 조상(lowest common ancestor), 분리 집합(disjoint_set)

### comment

 우선 우리는 이 문제와 반대로 임의의 간선을 반드시 포함하는 mst는 비교적 간단하게 구했다. ([문제](https://github.com/pill27211/Baekjoon/tree/main/Platinum/Graphs/15481_%EA%B7%B8%EB%9E%98%ED%94%84%EC%99%80%20MST))
 
 하지만 이번엔 임의의 간선을 포함하지 않을 때에 mst를 구해야 한다. 어떻게 해야 효율적으로 구할 수 있을까?
 
 우선 기본적인 흐름은 위 문제와 비슷하게 가져간다.
 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

우선 정답을 담을 자료구조로 맵을 택하자.

임의의 간선 i에 대한 답을 M[{v1, v2}] = x;  와 같은 형태로 저장하면 임의의 두 정점을 잇는 간선을 비교적 간단하게 표현할 수 있게 된다.

또, 두 정점쌍에 대해 일반성을 잃지 않도록 항상 {v1 < v2} 를 만족하도록 저장하자. (간선들을 입력 받으면서 처리)

그리고 mst를 구축하면서 입력 받은 간선들의 순서가 가중치 순으로 정렬되기 때문에 따로 복사 간선 배열을 만들어 주자. (그래야 나중에 입력 받은 순으로 정답을 출력할 수 있으니)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

최초 mst를 구축하면서 임의의 간선 i에 대해 i를 포함 시킬지 vs 안시킬지로 나뉘는데 각각 중요한 자원이 된다.

만약 간선 i가 포함 된다면 위에서 언급한 문제에서 다룬 내용처럼 mst상의 lca 및 희소 배열 전처리를 위해 따로 모아줘야 한다.

그렇다면 포함 되지 않을땐 ?

이또한 임의의 간선 j가 최초 mst에 포함될 때 이 j를 포함하지 않는 mst를 구하기 위해 사용될 가능성이 있는 중요한 간선이 된다.

따라서 mst에 포함 되는 간선, 포함 되지 않는 간선 각각 따로 모아두자.

추가로 정답을 담을 맵에 mst에 포함 되는 간선들은 따로 정답을 구해야 한다고 마킹을 해두자.(-1)

포함 되지 않는 간선들은 어차피 답이 최초 mst 가중치의 합이기 때문에 굳이 구할 필요가 없다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

위에서 언급한 문제에선 lca 전처리를 진행하면서 '해당 시점의 가장 큰 가중치'를 저장해 뒀었다.

이번엔 이를 조금 달리 하여, 정점에 해당 정점을 잇는 간선의 가중치를 저장해두자. (1을 루트로 위에 두고, 아래로 뻗어 나가는 트리 모양이라고 생각)

무슨 말이냐면 예를 들어 정점 1이 2와 가중치 3으로 연결되어 있고 정점 3은 2와 5로 연결되어 있다면 C[2] = 3, C[3] = 5와 같이 말이다.

그렇게 전처리를 끝냈다면 이제 모아두었던 '포함 되지 않는 간선'들의 집합{A}을 차례로 순회하며 '포함 되는 간선'들의 집합{B}에 대한 답을 찾아줄 것이다.

어떻게 해야 효율적으로 답을 찾아줄 수 있을까?

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

A의 임의의 간선 i가 두 정점 v1, v2를 잇는다고 해보자.

그럼 i는 '두 정점 v1, v2를 잇는 mst의 경로 상의 모든 간선{D}들을 대체할 수 있다.

한가지 더 중요한 것은, D에 대해 아직 답이 구해지지 않은 간선이 있다면 최초로 만나는 i가 가장 mst에 가까운 대체 간선이라는 것이다.

"아직 모르지 ! 남은 A 집합에 더 작은 가중치를 가진 대체 간선이 있을 수 있잖아!"

-> 아니다. 왜냐하면 우린 최초 mst를 구축할 때 입력 받은 모든 간선을 (가중치 기준) 오름차순으로 정렬했다. 그렇다면 집합 A에 추가 되는 간선들은 ?

그렇다. 당연히 오름차순을 지키며 순서대로 저장된다.

따라서 임의의 간선 i를 최초로 만나는 집합 D 내에 간선들의 답은, i가 최선의 대체 간선임이 증명된다.

하지만 순회하는 간선들마다 경로 상의 모든 간선들을 매번 보고 있으면 당연히 TLE 확정이다. 이때 떠오르는 것이 바로 경로 압축 즉, 유니온 파인드이다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

경로가 유일한 트리 + 지난 시점은 이미 답이 구해졌을테니 모든 정점들을 답이 특정된 집합 vs 구해야 하는 집합으로 나눌 수 있다.

한참 전에 mst를 처음 만들 때 썻던 dsu배열을 다시 초기화를 시키고 써먹어보자.

이제 우리가 할 일은 i에 대해 D상의 모든 간선들의 답을 구해주면서 동시에 같은 집합으로 합쳐 경로 압축을 시켜주는 것이다.

당연히 v1, v2의 lca를 구해주고 각각 lca를 향해 올리면서 모든 간선을 돌아보자.

이때 우리는 위에서 전처리한 C[]를 이용할 수 있다.

희소 배열에서 v1 바로 위의 정점은 dp[v1][0]이며 일반성을 유지함에 따라 {v1, k}가 가중치 C[x]가 잇고 있는 상태이다.

이에 따라 M[{v1, k}] = s - C[x] + i.w 가 된다.

여기서 중요한 건

* v1 < k
* s : 최초 mst 가중치 합
* C[x] = D[x] < D[y] ? C[y] : C[x] (위에서 언급한 C[] 조건에 따라 깊이가 더 깊은 정점에 저장된 C[]값이 현재 보는 간선의 가중치가 됨)
* i.w : 집합 A에 포함된 대체 간선이 될 간선의 가중치

이 흐름을 집합 A를 순회하며 진행해주면 된다. 초반부에야 연산이 많을 수 있지만, 점점 경로 압축이 됨에 따라 충분히 빠른 시간 내에 모든 답을 특정할 수 있다.

최종적으로 입력 받은 순으로 간선들을 순회하며 M[]가 0이라면 집합B에 속한 간선이므로 s 출력, 아니라면 답이 담겨있을 테니 M[]를 출력하면 끝.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
