
# [Platinum III] All Solve를 향해! - 26158

[문제 링크](https://www.acmicpc.net/problem/26158)

### 문제 요약

<p> N개의 문제 난이도가 주어진다. 문제에 주어진 방식대로 문제들을 풀어나갈 때, 모든 문제를 풀기 위해 필요한 최소 일 수를 구해보자. </p>

### 제한

TL : 2sec, ML : 1024 MB

1 ≤ N, K ≤ 500,000

1 ≤ N_i ≤ 1,000,000,000

### 성능 요약

메모리: 7884 KB, 시간: 96 ms

### 분류

자료구조(data structures), 세그먼트 트리(segment tree), 이분 탐색(binary_search)

### comment

우선 당연히 나이브하게 짜면 TLE 확정이다. 대략 O(NlogN)정도의 복잡도를 가져야될 듯 하다.

<del> 처음에 최댓값 세그를 쓰고 시뮬레이션을 구데기같이 돌려서 TLE를 한 번 얻어 맞았다. </del>

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

다음과 같이 두 개의 보조 배열과 보조 변수를 추가하자.

* 각 날에 풀었던 문제들 중 가장 어려운 문제를 저장한다. 즉, M[i] : i번째 날에 푼 가장 어려운 문제 난이도
* 각 날에 푼 문제의 수를 저장한다. 즉, C[i] : i번째 날에 푼 문제의 수
* p, q -> 현재 보고 있는 구간 정보 범위를 표현

그리고 모든 문제들을 순회하며 다음의 로직을 거치자.

* 해당 문제를 기점으로 새로운 날이 시작 되어야 하는가 ? 아니면 해당 문제는 풀린 문제인가 ?
* 이제 볼 필요 없는 구간 정보를 들고 있지는 않은가 ?

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

먼저 해당 문제를 기점으로 새로운 날이 시작 되어야 할 때는 언제일까 ? 이는 간단하게 생각해낼 수 있다.

현재 보고 있는 구간 정보의 최신 최댓값(M[q - 1])과 현재 판단해야 할 문제(a[i])의 난이도를 비교했을 때, M[q - 1] >= a[i]라면 새로운 날이 시작 되어야 한다.

왜냐하면 반대로 a[i]가 M[q - 1]보다 컷다면, a[i]는 이미 풀린 문제라는 뜻이기 때문이다.

따라서 q번째 날에 풀리기 시작한 새로운 문제가 되므로 C[q]++, M[q++] = a[i];

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

그렇다면 해당 문제가 이미 풀린 문제라면, 어떤 처리를 해줘야 할까 ?

당연히 어떤 날에 풀린 문제인지 찾아줘야 한다. 바로 이 때 이분 탐색을 적용할 수 있다.

배열 M[]는, 문제에서 주어진 풀이 방식에 따라 '현재 보고 있는 구간 정보에서' 단조 감소 한다.(위에서도 이것을 이용해 새로운 날 시작 유무를 판단하였음)

이를 역으로 뒤집어 생각해보면, 오름차순 정렬이 되어 있음을 뜻하며 역방향 이분 탐색을 적용할 수 있다는 뜻이다.

따라서 현재 보고 있는 구간 정보에서 a[i]로 이분탐색을 돌렸을 때 최초로 특정되는 M[]의 위치가 바로, a[i]가 풀린 날이 된다.

이에 따라 해당 날의 최댓값을 a[i]로 바꿔주고(M[x] = a[i]), 풀린 문제가 추가 됐으므로 C[x]++;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

이후 k값에 따라 더는 볼 필요가 없어진 가장 오래된 날(p)을 적절히 손절해 주며 최종 q의 값을 출력해 주면 된다.(q가 곧 현재까지 진행된 날의 수를 의미하므로)

곰곰이 생각해보니 구간의 최댓값 + 인덱스를 담는 세그먼트 트리를 써서 보는 구간의 최좌측 값을 찾아가며 시뮬레이션을 돌려주면 약간 상수가 큰 O(NlogN) 풀이가 가능할 듯 싶다.

나중에 세그로도 다시 풀어 봐야지..
