
# [Gold III] 행렬 곱셈 순서 - 11049

[문제 링크](https://www.acmicpc.net/problem/11049)

### 문제 요약

<p> N개의 행렬이 주어진다. 이때, 모든 행렬을 곱하는데 필요한 곱셈 연산 횟수의 최솟값을 구해보자. </p>

### 제한

TL : 1sec, ML : 128 MB

1 ≤ N, r, c ≤ 500

항상 순서대로 곱셈을 할 수 있는 크기만 입력으로 주어진다.

최악의 순서로 연산해도 항상 2^31 - 1의 값을 넘지 않으며, 답 또한 이 값을 넘지 않는다.

### 성능 요약

메모리: 3004 KB, 시간: 160 ms

### 분류

다이나믹 프로그래밍(dp)

### comment

dp[i][j] : i번 행렬부터 j번 행렬까지 곱하는데 필요한 연산의 최솟값.

i와 j의 차이가 1일 경우 두 행렬을 곱하는데에 필요 연산이 곧 연산의 최솟값이다.(i == j일 때는 당연히 0) 이를 기저 조건으로 잡고 시작하자.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

우선 전체 행렬을 곱하는데 필요한 연산의 최솟값을 구하기 위해 여러가지 연속 부분 행렬 형태로 쪼개봐야 한다.

a_1과 a_2 ~ a_n의 부분 행렬로 쪼개었을 때 최소인가 ? 혹은 a_1 ~ a_2 과 a_3 ~ a_n로 쪼개었을 때 최소인가 ? 등등 가능한 모든 형태의 부분 행렬을 조사해봐야 한다.

따라서 다음과같은 식이 나온다. (최초의 p와 q는 1과 N)

dp[p][q] = min(dp[p][q], f(p, i) + f(i + 1, q) + a[p] * b[i] * b[q]);

i = p를 시작으로 p ~ i, i + 1 ~ q 의 부분 행렬로 쪼개보며 최솟값을 찾아보는 것이다.

이때 f(p, i)과 f(i + 1, q)는 두 부분 행렬 각각의 연산 최솟값에 해당하며 (a[p] * b[i] * b[q])는 두 부분 행렬을 곱하는 연산의 수가 된다.
