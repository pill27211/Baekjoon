
# [Gold I] 외판원 순회 - 2098

[문제 링크](https://www.acmicpc.net/problem/2098)

### 문제 요약

<p> Do you know TSP ? </p>

### 제한

TL : 1sec, ML : 128 MB

2 ≤ N ≤ 16

1 ≤ W[i][j] ≤ 1,000,000

항상 순회할 수 있는 경우만 입력으로 주어진다.

### 성능 요약

메모리: 6116 KB, 시간: 28 ms

### 분류

다이나믹 프로그래밍(dp), 비트마스킹(bitmask), 비트필드를 이용한 다이나믹 프로그래밍(dp_bitfield)

### comment

널리 알려진 외판원 순회 문제에, 비트dp 테크닉을 접목시킨 대표 문제이다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

비트 연산에 익숙치 않으면 다소 난해하다고 느낄 수 있다.

n == 16임에 따라 16개의 비트를 생각해보자.

B : 0000 0000 0000 0000 0000

이때 이 비트열을

B : 0000 0000 0000 0000 1000

와같이 만들기 위해서 필요한 연산은 ?

B | (1 << 3) 의 비트 연산을 진행해주면 된다.

그럼 위 비트열에서 (1 << 3) 번째 비트가 켜져있는 지 확인하기 위해서는 ?

B & (1 << 3) 의 비트 연산을 진행해주면 된다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

추가로 모든 비트가 켜져 있는지 확인하기 위해서는 어떤 연산이 필요할까 ?

비트 단위의 움직임이 갖는 특성을 알고 있는 사람이라면, 바로 떠올릴 수 있을 것이다.

B : 1000 0000 0000 0000 0000

의 상태에서 B - 1 의 값을 위 비트열로 표현하면

B : 1111 1111 1111 1111 1111

가 된다. 

이를 이용해 연산식을 정리하면 B == (1 << 19) - 1 가 되고, 이 조건식이 참이라면 모든 비트가 켜져 있음을 뜻하게 된다.

이 세가지 연산을 이해했다면 이제 이 비트 필드를 이용해 다이나믹 프로그래밍을 해보는 데에 무리가 없을 것이다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

방문한 도시 상태를 그대로 위에 비트열로 생각해보자.

그럼 "추가로 모든 비트가 켜져 있는지 확인하기 위해서는 어떤 연산이 필요할까 ?" 는 자연스레 모든 도시를 방문했는가 ? 로 바뀌고 또 이것은 기저 조건이 된다.

같은 맥락으로 "위 비트열에서 (1 << 3) 번째 비트가 켜져있는 지 확인하기 위해서는 ?" 는 자연스레 임의의 도시를 방문했는가 ? 로 바뀐다.

이제 더이상의 설명은 필요치 않으므로 끝.
