
# [Platinum IV] Piet - 15949

[문제 링크](https://www.acmicpc.net/problem/15949)

### 문제 요약

<p> 'Piet'이라는 프로그래밍 언어가 있는데, 이 언어 특유의 연산 원리 중 일부를 구현해보는 문제이다.(그냥 빡구현) </p>

### 제한

TL : 1sec, ML : 512 MB

1 ≤ N, M ≤ 100

종료되지 않는 프로그램은 입력되지 않는다.

가장 왼쪽 위 코델은 검은색이 아님이 보장된다.

### 성능 요약

메모리: 2040 KB, 시간: 0 ms

### 분류

구현(implementation), 시뮬레이션(simulation), 그래프 이론(graphs), 그래프 탐색(graph_traversal)

### comment

chokim159님의 추천을 받아 풀어본 구현 문제다.

구현 문제답게 하라는데로 하면 된다만.. P4 문제답게 그 하라는 게 약간 까다롭다.(출처가 UCPC 2018 본선 문제..)

대략적인 틀을 구상하고 바로 구현에 들어가보자.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

* 우선 방향을 {1, 2, 3, 4} -> {위, 오른 쪽, 아래, 왼 쪽} 과 같이 잡아뒀으며, CC는 {1, 2} -> {왼 쪽, 오른 쪽}과 같이 잡아뒀다.


1. 현재 보고 있는 점이 포함된 영역 전체를 구해보자. (V1에 담기며, 시작 점은 {1, 1})

2. V1에서 DP값에 따라 가장 멀리 위치한 코델 후보들을 따로 뽑는다. (V2에 담기며, 시작 DP값은 2)

3. V2에서 CC값에 따라 가장 끝에 있는 코델을 뽑는다.

4. DP방향으로 한 칸 이동한 곳이 맵을 이탈한 곳이거나 검은색 블록이라면 change()에서 8가지의 경우의 수를 돌아보며 이동을 시도한다. 카운트가 8을 넘어가면 모든 경우를 다 돌아봤음에도 이동할 곳을 찾지 못했다는 것이므로 기록된 an문자열 출력 후 프로그램 종료.

+ change()에서 CC값을 바꾸는 과정과 DP값을 바꾸는 과정이 나뉘는데, CC값을 바꿀 경우 1, 2를 생략해도 된다.(어차피 목록은 같으니) CC를 업데이트 한 후에도 이동이 불가하면 DP값이 바뀌기 때문에 1번으로 돌아간다. 여기까지 끝나야 카운트가 1 증가하게 됨.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

작성하면서 여기 수정하고 저기 수정하고 하느라 코드가 너무 날 것의 느낌이 난다. 역시 빡구현 문제일수록 원트 AC가 아니면 꽤나 스트레스를 받게 될 수 있다. (가끔 아예 갈아엎고 처음부터 짜는 것이 더 빠를 수 있을 정도)

그렇게 1안을 제출해봤더니 퍼센트가 상당히 빠르게 쭉쭉 올라가서 흐뭇하게 지켜보다가 갑자기 90퍼 언저리에서 88....89................ 시간 초과 !

보통 퍼센트 앞쪽이 상대적으로 빡빡한 데이터들이고 후반부일수록 얕은(실수를 유발하는) 코너 케이스가 배치된다.

그래서 당연히 코너 케이스를 의심했는데 이것 저것 만들어봐도 잘 돌아갔다.

더군다나 빡구현 문제라 살짝 뇌정지가 왔다. 차라리 퍼센트 초반부에서 TLE나 WA 아 내가 접근을 잘못 했나 ? 하면서 로직을 의심하고 재구상을 해보거나 할텐데 90퍼 TLE는...

그리고 이 정도 데이터 범위면 시간복잡도 문제라기보다 무한 재귀나 UB 등 스택 오버 플로우로 인한 TLE를 의심해야 한다. 그러나 탈출 조건도 잘 걸어둔 상태라 문제점이 딱히 안보여서 갈아 엎기로 마음을 먹고 마지막으로 처음부터 찬찬히 코드를 읽어보기 시작 했는데 상당히 바보같은 실수를 했다.

문제의 맵은 n * n의 정사각형이 아닌 n * m의 직사각형 형태이다. 그런데 나는 맵 범위 체크 부분(BFS할 때랑 4번 로직 수행할 때)에서 y <= n && x <= m 이 아닌 y <= n && x <= n 과 같이 작성하였다. 하하하..

이후 단 두 글자를 수정하고 제출하니 깔끔하게 AC.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

++ 처음에 대체 어떻게 90%까지 올라간 거임 ?????
