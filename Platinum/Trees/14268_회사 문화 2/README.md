
# [Platinum III] 회사 문화 2 - 14268

[문제 링크](https://www.acmicpc.net/problem/14268)

### 문제 요약

<p> 트리가 주어진다. 이때, 한 정점의 서브트리에 업데이트 쿼리 || 점단위 합쿼리를 적절히 처리해 보자. </p>

### 제한

TL : 5sec, ML : 512 MB

1 ≤ N, Q ≤ 100,000

### 성능 요약

메모리: 12844 KB, 시간: 60 ms

### 분류

자료 구조(data structure), 트리(trees), 세그먼트 트리(segment tree), 느리게 갱신되는 세그먼트 트리(lazy propagation), 오일러 경로 테크닉(euler_tour technique)

### comment

선형 구조에서의 구간 단위 업데이트 쿼리와 점단위 합쿼리는 비교적 간단하게 해결할 수 있다. 하지만 선형 구조가 아닌 비선형 구조(트리)라면 어떻게 해야 효율적으로 쿼리들을 처리할 수 있을까 ?

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

비선형 구조인 트리를 선형 구조처럼 다룰 수 있다면 우리가 알고 있는 선형 구조에서의 쿼리 처리 방식을 적용할 수 있지 않을까 ?

이때 바로 등장하는 것이 '오일러 투어 테크닉'이다.

임의의 정점에 대해 진입 시점과 끝나는 시점(더이상 이어질 것이 없는)을 안다면, 이 구간을 해당 정점의 서브트리라고 볼 수 있게 되며 

"한 정점의 서브트리에 업데이트 쿼리" 는 자연스레 "한 정점의 진입 시점 ~ 끝나는 시점에 업데이트 쿼리" 로 바뀌게 된다.

이에 따라 당연히 점단위 합쿼리는 "한 정점의 진입 시점 ~ 진입 시점에 합쿼리" 로 바뀌게 된다.

이렇듯 트리에서의 오일러 투어 테크닉은 비교적 간단한 코드로 굉장히 강력한 이점을 얻을 수 있게 된다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

문제에선 각 직원의 직속 상사 번호가 주어진다고 했으니 직속 상사 -> 해당 직원 방향으로 간선을 세팅해주고 ett를 돌려주자.

* i번째 직원이 직속 상사로부터 w만큼 칭찬을 받는다.

-> i번째 직원을 포함한 그 서브 트리에 w만큼 업데이트 쿼리를 날린다.

-> i번째 직원의 진입 시점 ~ 끝나는 시점에 w만큼 업데이트 쿼리를 날린다.

-> seg_update(1, 1, n, in[i], out[i], w)

* i번째 직원이 칭찬을 받은 정도를 출력한다.

-> i번째 직원의 진입 시점 ~ 진입 시점에 합쿼리를 날린다.

-> seg_query(1, 1, n, in[i])

펜윅을 쓰던, 단일 세그를 쓰던, 세그 + 레이지를 쓰던 자신이 편하게 쓰던 방식을 사용해 처리해주면 된다.
