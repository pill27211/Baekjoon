
# [Gold III] 파일 합치기 - 11066

[문제 링크](https://www.acmicpc.net/problem/11066)

### 문제 요약

<p> N개의 수가 주어진다. 연속성을 유지하며 임의의 두 수를 합칠 때, 최종 하나의 파일로 만들기까지의 최소 비용을 구해보자. </p>

### 제한

TL : 1sec, ML : 128 MB

3 ≤ N ≤ 500

3 ≤ N_i ≤ 10,000

### 성능 요약

메모리: 3004 KB, 시간: 596 ms

### 분류

다이나믹 프로그래밍(dp)

### comment

dp[i][j] : i번 파일부터 j번 파일까지 하나의 파일로 만드는데에 드는 최소 비용.

[이 문제](https://github.com/pill27211/Baekjoon/tree/main/Gold/DP/11049_%ED%96%89%EB%A0%AC%20%EA%B3%B1%EC%85%88%20%EC%88%9C%EC%84%9C)와 결이 비슷하다.

<del> TMI : 최근에 탑다운 방식으로 DP문제를 푸는 것에 재미들려 만물 탑다운DP를 몸소 실천하고 있는 중이다. </del>

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

필요 이유는 뒤에서 설명할테니 N개의 수를 입력 받으면서 동시에 누적 합 배열로 만들자.

위에서 언급한 문제처럼 이 문제에서도 가능한 모든 형태의 부분 파일로 쪼개보면서 최소 비용을 찾아야 한다.

이에 따라 다음의 식이 도출된다. (최초의 p와 q는 1과 N)

dp[p][q] = min(dp[p][q], f(p, i) + f(i + 1, q) + a[q] - a[p - 1]);

여기서 f(p, i)와 f(i + 1, q)는 두 부분 파일 각각을 하나의 파일로 만드는데에 드는 최소 비용이다.

a[q] - a[p - 1] 이 식은 두 부분 파일을 합치는 비용으로 현재 보고 있는 구간의 총 합(파일량)이다.

하나 짚고 넘어가야 할 건 dp배열은 엄연히 "최소 비용"을 담는 배열이다.

우리는 현재 보고 있는 구간을 임의의 두 개의 부분 파일로 쪼개서 최소 비용을 찾았다.

이때 두 부분 파일을 합치는 데에 드는 비용은 두 부분 파일을 어떻게 나눴던간에 항상 현재 보고 있는 구간의 총 파일량이라는 것이다.

따라서 이를 모든 구간의 경우에서 O(1)에 처리할 수 있도록 최초에 누적 합 배열을 만들었던 것이다.

TC가 여러개로 이루어짐에 따라 적절히 초기화를 시켜주며 답을 찾아주면 끝.
