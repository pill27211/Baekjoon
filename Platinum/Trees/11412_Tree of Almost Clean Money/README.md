# [Platinum I] Tree of Almost Clean Money - 11412

[문제 링크](https://www.acmicpc.net/problem/11412)

### 문제 요약

<p> N개의 정점으로 이루어진 트리 및 각 정점의 가중치가 주어진다. x(i), y(i)를 이용해 Q개의 쿼리에 대한 답을 적절히 출력해보자. </p>

### 제한

TL : 4sec, ML : 256 MB

1 ≤ N ≤ 500,000

1 ≤ Q ≤ 50,000

1 ≤ K ≤ 1,000

### 성능 요약

메모리: 97652 KB, 시간: 3292 ms

### 분류

자료 구조(data structure), 트리(trees), 세그먼트 트리(segtree), heavy-light 분할(heavy-light decomposition)

### comment

솔직히 하고보면 별 게 없는 그냥 hld 기본 문제인데 쿼리 이해하는 데에 꽤 시간을 썻다.

이러한 형태의 쿼리 정의를 ps인생 처음 보기도 했고 영어 이슈까지 하하...

우선 hld로 트리를 선형으로 분할해주자. 또, 쿼리 내용을 보면 우리에게 필요한 연산은 업데이트, 합 쿼리다.

비교적 간단한 형태의 세그먼트 트리만 있으면 되므로 펜윅 트리를 이용해 구간 관리를 해주자.

그렇게 hld 전처리, 펜윅 트리에 최초 값 업데이트를 마쳤다면 쿼리 처리로 바로 넘어가보자.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

쿼리로 총 9개의 변수가 주어진다.

* { K, x(1), y(1), A, B, C, D, u, v }

또, 함수 x(i)와 y(i)는 다음과 같다.

* x(i) = (A * x(i - 1) + B) mod N
* y(i) = (C * y(i - 1) + D) mod 1000000007

여기에 K는 x(i), y(i)의 호출 범위 및 업데이트 횟수를 뜻한다.

또 x(1), y(1)는 각각 x(i), y(i)의 기저값에 해당 되며 A, B, C, D는 x(i), y(i)를 구성하는 차수가 된다.

남은 u, v는 최종 합쿼리의 범위가 되겠다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

예제로 예를 들어 보면, 첫번째 쿼리의 K가 1000임에 따라

1 <= i <= 1000 의 범위에서

x(1) 정점에 y(1) 값 업데이트, x(2) 정점에 y(2) 값 업데이트, ... x(999) 정점에 y(999) 값 업데이트, x(1000) 정점에 y(1000) 값 업데이트.

이런 식인 것이다.

즉, 업데이트 쿼리가 총 K번 이뤄진다는 것이다.

그런데 위에 x(i), y(i)의 정의를 보면 재귀의 형태로 이루어져 있다.

만약 나이브하게 값 업데이트를 하면 x(i)와 y(i)가 약 O(k^2)번 호출됨에 따라 쿼리당 O(k^2log N)만큼의 업데이트 시간이 필요하게 된다. (TLE)

따라서 쿼리마다 xdp[1001], ydp[1001]에 적절히 메모이제이션을 해주어 O(k log N) 으로 줄여주자.

이후, 정점 u, y를 잇는 경로 상에 합쿼리를 날려주면 끝이다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

정점의 수가 워낙 많아서 그런지, 펜윅으로 구간 관리를 했는데도 4초 제한에 3초 중반 조금 안되게 나왔다.

재귀로 세그를 짰다면 TLE와 줄타기를 했을 듯 싶다.

앞서 말했듯이 이런 형태의 쿼리 정의를 처음 봐서 재밌었던 문제이다. 꽤 기억에 남을 듯.
