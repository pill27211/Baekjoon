
# [Gold V] 파이프 옮기기 1 - 17070

[문제 링크](https://www.acmicpc.net/problem/17070)

### 문제 요약

<p> N * N의 맵이 주어진다. 문제의 조건대로 이동할 때, (1, 1)에서 (N, N)으로 이동하는 방법의 수를 구해보자. </p>

### 제한

TL : 1sec, ML : 512 MB

3 ≤ N ≤ 16

방법의 수는 최대 1,000,000이며, (1, 1)과 (1, 2)는 빈 칸임이 보장된다.

### 성능 요약

메모리: 2028 KB, 시간: 0 ms

### 분류

다이나믹 프로그래밍(dp)

### comment

dp[i][j][k] : 점(i, j)에 k번 방향으로 이동하며 도착하는 방법의 수.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

* 점(i, j)에 → 방향으로 이동하며 도착하는 방법의 수는 점(i, j - 1)의 가로 이동 + 대각선 이동과 같다.

: dp[i][j][0] += dp[i][j - 1][0] + dp[i][j - 1][2];

* 점(i, j)에 ↓ 방향으로 이동하며 도착하는 방법의 수는 점(i - 1, j)의 세로 이동 + 대각선 이동과 같다.

: dp[i][j][1] += dp[i - 1][j][1] + dp[i - 1][j][2];

* 점(i, j)에 ↘방향으로 이동하며 도착하는 방법의 수는 점(i - 1, j - 1)의 가로 이동 + 세로 이동 + 대각선 이동과 같다.

: dp[i][j][2] += dp[i - 1][j - 1][0] + dp[i - 1][j - 1][1] + dp[i - 1][j - 1][2];

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

우선 위 식은 점(i, j)가 빈 칸이라는 가정 하에 진행 된다.

이때, 문제의 그림을 보면 →, ↓ 방향 이동은 단지 해당 위치만 벽이 아니면 됐으므로 빈 칸인 모든 점에서 수행해도 문제가 없다.

하지만 ↘방향 이동은 해당 위치 뿐만 아니라 해당 위치 기준 왼 쪽, 위 쪽이 모두 빈 칸이어야만 이동이 가능하다.

따라서 세번째 이동은 점(i - 1, j)와 점(i, j - 1)이 함께 빈 칸일 때만 진행한다.

최종적으로 점(N, N)의 dp[N][N][0] + dp[N][N][1] + dp[N][N][2] 이 답이 된다.
