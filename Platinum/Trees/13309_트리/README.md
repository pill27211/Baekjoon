# [Platinum I] 트리 - 13309

[문제 링크](https://www.acmicpc.net/problem/13309)

### 문제 요약

<p> 서브태스크 문제이며, 트리가 주어진다. 독립적이지 않는 쿼리들을 순서대로 수행하며 적절한 답을 출력해보자. </p>

### 제한

TL : 2sec, ML : 512 MB

$1 ≤ N, Q ≤ 200,000$

### 성능 요약

메모리: 49304 KB, 시간: 324 ms

### 분류

자료 구조(data structure), 트리(trees), 세그먼트 트리(segtree), 오일러 경로 테크닉(euler tour technique), heavy-light 분할(heavy-light decomposition)

### comment

먼저 특이한(?) 점은 모든 쿼리가 서로 연관된다는 것이다.

모든 쿼리가 독립적이지 않고 $Q_1$이 $Q_2$에 영향을 주고, $Q_2$가 $Q_3$에 영향을 주고... 이런식으로 트리의 모양이 계속해서 변화할 수 있다. (-> 변화하는 트리를 어떤식으로던 가지고 있어야 한다.)

나는 $hld + segtree$로 해결했지만, 하고나니 $hld$까지 굳이 갈 필요가 없어 보이긴 하다.

우선 $hld$로 트리를 펴보자.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

변화하는 트리(간선)를 이렇게 바라보았다.

연결된 간선(0), 끊어진 간선(0보단 큰 수)

이에 따라, 최초의 트리는 모두 연결된 상태이므로 모든 $seg_value$가 0이다.

반대로 끊어진 간선이라면, $seg_value$가 0보다 큰 수가 되며 어떤 두 구간에 대한 합쿼리의 결과는 0 또는 0보다 큰 수가 된다.

즉, 연결 정보를 묻는 쿼리는 트리상 경로에 대해 합쿼리를 날리는 것으로 바뀌게 되며, 간선을 끊는 쿼리는 트리상 자식 정점에 대해 점단위 업데이트(+ 1) 쿼리를 날리는 것으로 바뀌게 된다.(위에서 아래로 향하는 세그트리를 머릿속으로 그려보면 당연하다.)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

위에서 연결된 간선을 0으로 뒀으므로 따로 세그먼트 트리에 전처리 해 놓을 것이 없다.

두가지 쿼리 통틀어 경로확인 쿼리는 위에서 말했다시피 두 정점을 잇는 경로에 대해 합쿼리를 날리는 것으로 끝난다. $hld$답게 체인 단위로 끌어 올리며 처리해주자.(0이면 NO, 이외는 YES)

$d == 1$인 쿼리엔 다음과 같은 추가적인 처리가 붙는다.

" $b$와 $c$를 연결하는 경로가 존재하는 지 묻는 질의를 수행하고, 대답이 “YES”이면, 이어서 $b$의 부모 정점과 $b$를 연결하는 에지를 제거한다. 대답이 “NO”이면, $c$의 부모 정점과 $c$를 연결하는 에지를 제거한다. 만약 제거하려는 에지가 원래 존재하지 않거나 이미 제거된 경우에는 제거되는 에지가 없다."

점단위 업데이트 쿼리기 때문에 점이 $in[b]$인지 $in[c]$만 위 합쿼리 결과에 따라 잘 정해주면 어렵지않게 처리할 수 있다.


"만약 제거하려는 에지가 원래 존재하지 않거나 이미 제거된 경우에는 제거되는 에지가 없다."

이 부분은 자체 일반화가 되는게, 위에서 끊어진 간선을 '0보단 큰 수'로 정의했기 때문에 1에서 또 1이 더해진다 해도 그저 끊어진 간선일 뿐이다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 합쿼리를 날릴 때 두 정점이 서로 다른 체인에 속해있는 경우가 아닌 같은 체인에 속해있는 경우, 경로에 대한 값이 정점에 담겨 있으므로 쿼리 범위는 $in[p] ~ in[q]$가 아닌 $in[p] + 1 ~ in[q]$다.

. 약간의 최적화 관련해서인데(당연한거지만), 합쿼리를 날릴 때 굳이 항상 경로 전체에 대해 다 날릴 필요가 없다.(물론 모든 경로가 이어져있다면 다 봐야 하게 됨)

$query$ 부분을 보면, 따로 결과를 담을 변수를 두어 경로 쿼리 결과를 계속 누적시키는 것이 아닌 임의의 경로에서 0보다 큰 수가 뽑히면 바로 함수를 종료하도록 구성했다.

어차피 0이 아닌 수가 중간에 튀어 나왔다는 건, 이후 경로를 볼 필요 없이 경로가 끊어졌다는 것이므로..

실제로 이 차이에 있어서 약 180ms 정도 차이가 났다. 이정도 데이터범위에선 유의미한 차이라고 봐도 될 듯 하다.
