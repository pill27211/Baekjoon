
# [Gold III] 팰린드롬 - 5502

[문제 링크](https://www.acmicpc.net/problem/5502)

### 문제 요약

<p> 문자열이 주어진다. 이때, 최소한의 문자만을 추가해 주어진 문자열을 팰린드롬으로 만들어 보자. </p>

### 제한

TL : 1sec, ML : 256 MB

3 ≤ N ≤ 5,000

### 성능 요약

메모리: 99720 KB, 시간: 76 ms

### 분류

다이나믹 프로그래밍(dp)

### comment

dp[i][j] : i번째 문자부터 j번째 문자까지의 기준에서 추가해야 할 문자 수

와 같이 dp테이블을 정의하고, 다음과같이 크게 두가지 경우로 분기해보자.

1. s[i] != s[j]일 때.
2. s[i] == s[j]일 때.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

2일 땐 바로 식을 도출해낼 수 있다.

-> s[i]와 s[j]는 이미 같으므로 당연히 그 사이 문자열(i + 1, j - 1)에 의해 dp값이 정해진다.

1일 땐 두가지 부분 문자열의 입장에서 생각해 볼 수 있다.

1. s[i] ~ s[j - 1]에 s[j]가 추가 된다고 생각하는 경우.
2. s[i + 1] ~ s[j]에 s[i]가 추가 된다고 생각하는 경우.

둘 중 어느 경우를 선택해야 할까? 당연히 두 부분 문자열 중 팰린드롬에 가까운 문자열(dp값이 더 작은 문자열)을 선택해야 한다.

따라서 위 과정을 일반화하면, 최종적으로 다음과 같은 점화식이 도출된다.

dp[i][j] = s[i] ^ s[j] ? min(dp[i][j - 1], dp[i + 1][j]) + 1 : dp[i + 1][j - 1];

이를 모든 범위에 대해 돌려준 후, 전체 문자열의 dp값인 dp[0][n - 1]을 출력해주면 된다.
