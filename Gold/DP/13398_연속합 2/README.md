
# [Gold V] 연속합 2 - 13398

[문제 링크](https://www.acmicpc.net/problem/13398)

### 문제 요약

<p> 길이 n의 수열이 주어진다. 필요에 따라 하나의 수를 지워도 될 때, 이 중 최대 연속합을 구해보자. </p>

### 제한

TL : 2sec, ML : 512 MB

1 ≤ n ≤ 100,000

-1,000 ≤ n_i ≤ 1,000

### 성능 요약

메모리: 3192 KB, 시간: 12 ms

### 분류

다이나믹 프로그래밍(dp)

### comment

dp[i][j] : i번째 수까지에서, 수를 지우지 않았을 때의 최댓값(dp[i][0])과 수를 하나 지웠을 때의 최댓값(dp[i][1])

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

먼저 우린 수를 지우지 않았을 때의 최대 연속합은 쉽게 구해낼 수 있다.([문제](https://www.acmicpc.net/problem/1912))

그러나 이번엔 수를 필요에 따라 하나까지 지워도 된다고 한다. 이때 최댓값은 어떻게 구할까 ?

그 흐름은 기본적인 최대 연속합과 크게 다르지 않다.

수열의 임의의 인덱스 i를 기준으로 다음과같이 나눌 수 있다.

* i번째 수를 지운다고 할 때.
* 1 ~ i - 1번째 수들 중 하나를 지운 상태일 때.

먼저 i번째 수를 지운다면 우린 이미 최댓값을 알고 있다. 바로 "이전 인덱스까지의 수를 지우지 않았을 때의 최댓값(dp[i - 1][0])" 이다.

그렇다면 1 ~ i - 1번째 수들 중 하나를 지운 상태일 땐 ? 이 경우엔 당연히 현재 i번째 수를 반드시 포함 해야 한다. 즉, dp[i - 1][1] + a[i].

따라서 최종적으로 수 하나를 지울때의 최댓값 점화식은 dp[i][1] = max(dp[i - 1][1] + a[i], dp[i - 1][0]); 와같이 도출된다.

모든 수열에서 위 점화식과 우리가 알고 있는 기본적인 최대 연속합 점화식을 돌려 주며 최댓값을 찾아주면 된다.
