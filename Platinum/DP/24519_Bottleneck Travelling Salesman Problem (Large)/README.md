
# [Platinum V] Bottleneck Travelling Salesman Problem (Large) - 24519

[문제 링크](https://www.acmicpc.net/problem/24519)

### 문제 요약

<p> 변형된 tsp + 역추적 </p>

### 제한

TL : 1sec, ML : 1024 MB

2 ≤ N ≤ 18

0 ≤ M ≤ N * (N - 1)

1 ≤ C ≤ 5,000,000

두 정점 사이에 같은 방향의 간선이 2개 이상 존재하지 않는다.

### 성능 요약

메모리: 38884 KB, 시간: 192 ms

### 분류

다이나믹 프로그래밍(dp), 비트마스킹(bitmask), 비트필드를 이용한 다이나믹 프로그래밍(dp_bitfield), 외판원 순회 문제(tsp)

### comment

기본적인 tsp에서 조금 변형되어, "정점 간 이동 비용의 최댓값을 최소화하면서 모든 정점을 방문하는 순회"를 찾는 것이 문제이다.

또, 이 과정에서 나타나는 경로를 출력해야 한다.

우선 앞서 비슷한 [역추적 문제](https://github.com/pill27211/Baekjoon/tree/main/Gold/DP/14590_KUBC%20League%20(Small))를 다뤘었다.

이부분에선 dp[][]에 저장되는 값들의 일반성이 유지되어 이를 그대로 경로 출력에 이용했었다.

하지만 이 문제에선 dp[][]에 저장되는 값들이 "정점 간 이동 비용의 최댓값의 최솟값"이 되기 때문에 이를 이용해 경로를 추적해내기가 좀 까다로울 듯 하다.

어떻게 해야할까?

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

우선 처음에 정답(정점 간 이동 비용의 최댓값의 최솟값)을 찾아내는 과정은 기본적인 tsp에서 정점 간 이동 비용의 최솟값을 갱신 시켜주기만 하면 되므로 설명은 생략하겠다.

그럼 이제 경로 추적이 문제인데.. 일단 정답을 찾아내는 과정을 그대로 다시 돌려보며 경로를 찾아내는 방식으로 해보았다.

결과는 메모리 20456 KB, 시간 860 ms로 꽤 빡빡하게 통과했다.

하지만 훨씬 간단한 방법이 존재했다. 바로 순간순간의 경로를 저장할 배열(int pt[18][1 << 18])을 추가로 만들어주는 것이다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

p : 현재 정점, q : 현재 비트 전이 상태 라고할 때

dp[p][q]가 정점 i와 연결되는 시점에 갱신이 이뤄진다고 해보자.

그럼 이때 pt[p][q] = i; 와같이 최신 갱신 정보를 업데이트 해주는 것이다.

이후 이 배열을 이용하면 순회가 있다는 가정하에 O(N)(사실상 O(1))만에 경로를 찾아낼 수 있게 된다.

(출력 방법은 말그대로 pt[][]를 이용하기만 되니 코드를 확인하자.)

이 방식을 이용했을때 메모리 38884 KB, 시간 192 ms 로 훨씬 빠른 시간내에 문제가 해결됨을 볼 수 있다. (물론 추가 배열을 통해 사용 메모리는 약 두 배 정도 증가한다)

앞으로 비슷한 dp역추적 문제를 마주하면 이 방식을 애용하게 될 것 같다.
