# [Platinum III] 트리 더하기 1 - 26262

[문제 링크](https://www.acmicpc.net/problem/15481)

### 문제 요약

<p> N개의 간선으로 이루어진 그래프가 주어진다. Q개의 순서쌍 쿼리(x, y)가 주어질 때, 각 쿼리마다 x와 y를 잇는 최단 경로의 길이를 구해보자. </p>

### 제한

TL : 2sec, ML : 1024 MB

2 ≤ N, Q ≤ 200,000

1 ≤ d ≤ 1,000,000,000

임의의 두 정점에 대해 중복 간선이 주어질 수 있다.

### 성능 요약

메모리: 71472 KB, 시간: 408 ms

### 분류

그래프 이론(graphs), 트리(trees), 최소 공통 조상(lowest common ancestor), 누적 합(prefix_sum)

### comment

단순히 트리에서 두 정점에 대해 최단 경로를 구하는 건 간단하게 해결할 수 있다.([문제](https://www.acmicpc.net/problem/1761))

하지만 이 문제를 보면 간선이 총 N개 주어진다고 한다. 즉, 사이클이 발생할 수 있다. (중복 간선이 들어오는 경우엔 큰 가중치를 버리면 트리가 되긴 함)

간선이 하나 추가됐을 뿐인데 꽤 복잡해진다..

우선 N개의 간선으로 이루어진 그래프에서 사이클을 떼어내는 방법이 잘 떠오르지 않는다면 풀어볼만한 굉장히 좋은 문제가 있다. ([문제](https://www.acmicpc.net/problem/20530))

이참에 사이클 분리 테크닉을 확실히 알아두자. 

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

우선 중복 간선에 대한 문제는 알아서 잘 처리할 수 있을 것이다. 나같은 경우 단순히 그냥 맵 자료구조를 이용해 중복 간선에 대한 대비를 해 주었다.

그래프에서 사이클을 적절히 분류했다면, 사이클에 속한 정점들을 v_1, v_2, ... , v_k라고 해보자.

이때, 주어진 그래프를 이렇게 해석해 볼 수 있다. "사이클을 이루는 k개의 정점들과, 각 v_i를 루트로 하는 k개의 트리"

감이 빠르다면 벌써 쿼리 처리에 대한 포인트를 알아 차렸을 것이다.

아래와 같이 두가지 경우로 분기해 쿼리에 대한 처리를 해보자.

* 순서쌍 (x, y)가 같은 그룹(트리)에 속한 경우
* 순서쌍 (x, y)가 다른 그룹(트리)에 속한 경우

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

먼저 같은 그룹에 속한 경우를 살펴보자.

이때는 간단하다. 위에서 언급한 문제를 풀었다면 기본적인 LCA 전처리를 통해 O(logN)만에 거리를 구해줄 수 있다.

(모든 v_i에 대해 v_i를 루트로 하는 트리 즉, W[x]는 x가 속한 트리의 루트(G[x])로부터 떨어진 거리가 된다)

순서쌍 (x, y)의 최단 경로의 길이를 d라고 하면

d = W[x] + W[y] - 2 * W[lca(x, y)];

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

이제 다소 까다로울 수 있는 다른 그룹에 속한 경우이다.

사실 이 경우를 다루기 전에, 사이클 내 이동에 관해서 한가지 생각해 볼 것이 있다. 사이클 내에선 트리와 달리 경로가 두 가지다.

이때 누적 합을 떠올려봐야 한다.

머릿 속에 시계를 그려보자. 나는 지금 3시에서 9시로 이동하려고 한다. 그러나 방향은 두가지로 시계 방향, 시계 반대 방향이 있다.

이때 최단거리는 무슨 방향이 됐건 한 방향으로의 누적합만 구하면 특정할 수 있다.

만약 3시에서 시계 방향으로 누적 합(S)을 구했다고 해보자.

이때 9시까지 가는 비용은 S[9] - S[3]이다. 그렇다면 반대 방향으로 3시에서 9시까지 가는 비용은 ?

3시에서 시계 방향으로 가다가 결국 3시로 돌아올 때까지의 총 비용을 M 이라고 하면, 결국 M - (S[9] - S[3])이 반대 방향으로 가는 비용 아니겠는가 ?

따라서 임의의 한 방향으로의 누적 합 전처리를 완료 했다면, 사이클 내 최단 거리 특정은 min(S[i] - S[j], M - (S[i] - S[j]))로 O(1)만에 구할 수 있게 된다.

최종적으로 순서쌍 (x, y)가 다른 그룹에 속한 경우에 대한 거리는 다음과 같이 나타낼 수 있다.

d = W[x] + W[y] + min(S[G[x]] - S[G[y]], M - (S[G[x]] - S[G[y]]));

W[G[x]] : 사이클을 이루는 정점들은 각 트리의 루트 정점이므로 루트 단위로 연산.

W[x] : x가 속한 트리의 루트(G[x])로부터 떨어진 거리.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

예전 처음 이 문제를 보았을 때 사이클에 대해 만만히 보고 대충 처리하다가 틀려 한 달 동안 방치해 뒀다가 다시 풀게 된 문제다..

개인적으로 '양분' 문제가 굉장히 많은 도움이 되었다. 맞왜틀을 겪으며 여기 수정하고 저기 수정하느라 코드가 먼가 난잡하고 날 것의 느낌이 난다..

나중에 깔끔하게 필요 없는 부분 버리고 최적화도 해서 다시 풀어 봐야겠다.

아무튼 오늘은 AC 받았으니 런.
