
# [Diamond IV] 두 번째로 작은 스패닝 트리 - 1626

[문제 링크](https://www.acmicpc.net/problem/1626)

### 문제 요약

<p> 무향 그래프가 주어진다. 이 그래프의 '두 번째로 작은 스패닝 트리'를 구해보자. </p>

### 제한

TL : 2sec, ML : 128 MB

1 ≤ V ≤ 50000

1 ≤ E ≤ 200,000

0 ≤ E.w ≤ 100,000

답은 2^31 - 1을 넘지 않는다.

### 성능 요약

메모리: 22288 KB, 시간: 116 ms

### 분류

자료구조(data structure), 그래프 이론(graphs), 트리(trees), 최소 스패닝 트리(minimum spanning tree), 최소 공통 조상(lowest common ancestor), 희소 배열(sparse table)

### comment

 문제의 정답률을 보면 알겠지만 정말 만만치 않은 문제이다. 더군다나 문제가 단 '한 줄'이다.. 상당히 멋진 문제인 것 같다.
 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

우선 당연히 두 번째 스패닝 트리(이하 sst)를 구하기전에, mst를 먼저 구해보자. 한가지 중요한 것은, 이 때 mst에 포함되지 않는다고 쓸모없는 간선이 아니라는 것이다.

sst로의 발전 가능성이 있는 아주 귀중한 녀석들이니 따로 모아두자.(V)

이후 V에 포함되는 애들이 sst로의 가능성이 있는지 판단하기 위해
[이 문제](https://github.com/pill27211/Baekjoon/tree/main/Platinum/Graphs/15481_%EA%B7%B8%EB%9E%98%ED%94%84%EC%99%80%20MST) 처럼 전처리를 해둬야 하는데.. 한가지 난감한 것이 있다. 저 문제에선 단순히 해당 간선을 포함하는 mst를 구하는 것이라 전처리 과정 및 find_lca 과정이 다소 단순했다. (그저 해당 시점의 가장 큰 가중치만 특정해두면 됐으니..)

하지만 이 문제에선 가장 큰 가중치는 물론이며 '두 번째로 큰 가중치'도 특정해야 한다. 왤까 ?

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

우리가 찾는 sst엔 절대적인 조건이 있다. 바로 W_sst > W_mst를 만족해야 한다는 것이다. 위에서 말한 가장 큰 가중치를 특정해서 sst를 만들 때, 만약 기존 mst의 가중치와 같으면 어떡할 것인가 ?

이럴 때 바로 sst가 없다고 판단하여 -1을 출력하거나 해당 시점을 pass 해 버린다면 모든 가능성을 확인해보지도 않았는데 답을 특정하려 하게 된다.

따라서 해당 시점의 후보 가중치(두 번째로 큰 가중치)도 반드시 특정해 두어야 한다.

개인적으로 이 두 번째로 큰 가중치를 전처리하는 것이 이 문제의 가장 큰 난관이 아닌가 싶다. (sparse table을 만들면서 몇 번이나 곱씹어보면서 작성했다..)

말로 옮기기엔 좀 주저리주저리 길어질 것 같아서, ps러답게 코드로 이해해보자(올린 코드 68 ~ 70행). 간단히 말하자면, 해당 시점에 두 번째로 큰 애를 특정할 수 있는 모든 가능성을 확인하는 것이다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

한가지 주의할 게 있는데 이 문제에서 주어지는 그래프는 sst이전에 mst가 존재함을 보장하지 않는다. 최초 mst를 구축할 때 mst에 포함되는 간선 수를 카운트 하면서, 이 카운트 수가 V - 1을 만족하는지 꼭 확인하자.

이제 처음에 모아둔 간선배열 V를 순회하면서 모든 경우를 돌아볼 일만 남았다.

V 내 임의의 간선 e가 두 정점 v, u를 가중치 w로 이을 때,

sst의 가중치 합은 s - g + w 가 된다.

이 때 s, g의 의미는 다음과 같다.

s : 최초 mst 가중치 합

g : v, u의 경로상에 가장 큰 가중치이며, g ^ -1 && g ^ w 를 만족해야 한다.

g가 -1이라는 것은 후보 가중치가 존재하지 않음을 의미하며, g가 w라는 것은 sst 가중치 합이 s와 같다는 것이므로 제외한다.

lca를 찾아가며 sparse table에서  g ^ w인 가장 큰 가중치를 뽑는 것은 이 문제를 시도하는 분들이시라면 충분히 하실 수 있을테니 자세한 설명은 생략.(lca찾아갈 때 해당 시점의 두 sparse table을 같이 확인해 주면 됨)

이제 이렇게 모든 경우를 돌아본 후에도 sst값이 특정되지 않았다면 sst가 존재하지 않으므로 -1, 특정됐다면 그 결과를 출력해주면 된다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

풀면서 까다로운점이 꽤 많았고, 얼핏하면 수많은 예외에 고통받을 수 있는 문제였다. 지금은 약 4달이 지났지만 처음 다이아의 벽을 제대로 느끼게 한 문제였다.
