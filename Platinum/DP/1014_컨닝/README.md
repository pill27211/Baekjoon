
# [Platinum IV] 컨닝 - 1014

[문제 링크](https://www.acmicpc.net/problem/1014)

### 문제 요약

<p> 문제의 배치 규칙을 따를 때, 학생들을 최대로 배치할 수 있는 경우를 찾아보자. </p>

### 제한

TL : 2sec, ML : 512 MB

$1 ≤ n, m ≤ 10$

$1 ≤ E ≤ 100,000$

### 성능 요약

메모리: 2060 KB, 시간: 24 ms

### 분류

다이나믹 프로그래밍(dp), 비트마스킹(bitmask), 비트필드를 이용한 다이나믹 프로그래밍(dp_bitfield), 최대 유량(flow)

### comment

최대 유량 || 이분 매칭을 이용해 풀이될 수도 있지만, 요새 비트dp에 재미들려서 이걸로 해보았다.

$dp[i][j] : i - 1$행의 배치가 $j$로 표현될 때 최대로 배치할 수 있는 경우의 수.

열에 대한 정보를 비트열로 표현하므로, 입력으로 주어지는 맵 또한 비트열( $a[], 'x'$인 비트는 1)로 표현하여 통일 시켜주자. (이후 로직에서 간단하게 이용됨)

탑다운 함수에선 2개의 파라미터(현재 행, 이전 행의 배치 정보를 담고 있는 비트열)를 관리한다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

일련의 행에 대한 배치 경우의 수를 판단하기 위해 우선 0부터 최대 범위( $1 << m$ )까지 돌아보며 배치 가능 여부 판단은 내부에서 진행하였다.

우선 기본적으로 $a[]$와 & 연산을 통해 $'x'$자리에 배치 되었는지를 판단하자. (하나라도 걸렸다면 &연산에서 1 이상의 값이 나온다 즉, 0이어야 다음 경우로 넘어가볼 수 있다)

위 경우를 통과 했다면, 문제의 그림으로 표현된 조건을 검사해 보아야 한다.

현재 비트열($i$) 전체를 돌아보며 켜진 위치에 대해 검사해보자. ( $0 ~ m$ 에 대해 $i$ & $(1 << j) == 1$ 인 곳)

←, ↖, ↗ 방향에 대해서만 검사해주면 된다.

→ 방향은 고려하지 않아도 되는게, 만약 여기서 걸릴 비트열이었다면 $j + 1$번 비트열 검사 때 ← 방향에서 걸리게 되기 때문이다.

* ←  $: i$ & $(1 << (j - 1))$
* ↖ $: q$ & $(1 << (j - 1))$
* ↗ $: q$ & $(1 << (j + 1))$

($i$ : 현재 비트열, $q$ : 이전 행의 배치 정보를 담고 있는 비트열)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

위의 조건을 통과하는 모든 배치에 대해 최댓값을 찾아주면 된다. (기저 조건은 당연히 모든 행을 지나쳤을 때가 되겠다)

아 추가로, 1인 비트의 개수를 셀 때 $__builtin_popcount()$ 를 이용하였는데, 이는 표준이 아니라 확장 함수로 알고 있다.

boj 채점 컴파일러의 베이스가 gcc라서 지원된 듯..

하지만 찾아보니 c++20 의 [bit](https://en.cppreference.com/w/cpp/header/bit) 헤더에서 비트 연산 관련 함수들을 지원해준다고 한다. (위의 함수는 $popcount()$라는 함수로 대체할 수 있다)
  
기억해두면 종종 써먹을 때가 생길 수도 ?
