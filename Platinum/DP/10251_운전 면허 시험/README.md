
# [Platinum V] 운전 면허 시험 - 10251

[문제 링크](https://www.acmicpc.net/problem/10251)

### 문제 요약

<p> 2차원 맵이 주어진다. 문제에서 주어진 규칙에 따라 이동할 때, (1, 1)에서 (N, M)로 가는 최단 시간을 구해보자. </p>

### 제한

TL : 2sec, ML : 256 MB

2 ≤ N, M ≤ 100

1 ≤ L ≤ 10

1 ≤ G ≤ 1,000,000

1 ≤ a_i ≤ 1,000

### 성능 요약

메모리: 12800 KB, 시간: 268 ms

### 분류

다이나믹 프로그래밍(dp)

### comment

상당히 오랜만에 접해보는 4차원 DP 문제다.

DP 테이블을 다음과같이 정의 해보자.

dp[i][j][k][w] : 점 (i, j)까지 k번 방향 전환을 해 w방향을 바라보며 도착하는 데 드는 최소 연료량.

a[i][j][w] : w방향으로 점 (i, j)에 뻗어진 도로에서 소모되는 연료량.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

임의의 점 (i, j)에 k번 방향 전환을 해 도착하는 경우를 계산해야 한다고 해보자.

이때 위 경우를 어떻게 구할 수 있을까 ? (= 어떻게 식을 세울 수 있을까?)

다행히 문제의 규칙을 보면 두 방향(→, ↓)으로만 이동할 수 있다고 한다.

따라서 구해야 하는 값은 두가지로 dp[i][j][k][0] {→} 과 dp[i][j][k][1] {↓} 가 된다.

dp[i][j][k][0]을 보면, 당연히 왼 쪽 dp(dp[i][j - 1])값에 영향을 받는다.

이때 어떤 값이 고려되어야 할까?

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

이동 방향은 두 방향 뿐이기에, 다음의 두 값을 고려해볼 수 있다.

* → 방향으로 이어져 오는 경우(즉, →→ 모양) : dp[i][j - 1][k][0] + a[i][j][0];
* ↓ 방향을 거치고 이어져 오는 경우(즉, ↓→ 모양) : dp[i][j - 1][k - 1][1] + a[i][j][0];

두번째 값에서 dp[i][j - 1][k - 1][1] 가 나오게 된 이유는 다음과 같다.

점(i, j)에 ↓로 들어오고([1] 방향), 점(i, j + 1)에 가기 위해 방향을 꺾어야 하니 k값이 1증가 해야 한다. 따라서 k가 아닌 k - 1의 값을 고려해야 하는 것이다.

이에 따라 점화식을 다음과같이 정리할 수 있다.

dp[i][j][k][0] = min(dp[i][j - 1][k][0], dp[i][j - 1][k - 1][1]) + a[i][j][0];

dp[i][j][k][1] 값을 찾기 위한 점화식도 똑같은 원리로 정리된다.

dp[i][j][k][1] = min(dp[i - 1][j][k][1], dp[i - 1][j][k - 1][0]) + a[i][j][1];

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

이제 답을 도출해보자.

일단 모든 도로를 지나는 이동 시간에 있어서 그 비용은 항상 L로 일정하다.

따라서, 최단 시간은 방향 전환 횟수에 절대 의존적이다.

즉 dp[n][m][k][0 || 1]에서 그 값이 g를 넘지 않는 최초의 k(1, 2, 3 ...)가 바로 해답이 된다.

r = k + l * (n + m - 2);

(l * (n + m - 2) 는 →, ↓ 방향으로 이동하며 도착하는 데 지나는 도로의 수. 항상 일정하다)

g를 넘지 않는 dp[n][m][k][0 || 1]가 특정되지 않았다면 도착할 수 없다는 것이므로 -1 출력.

+ 아 그리고 위 dp식을 적용하기 위해선 참조하는 값의 위치 때문에 가장 윗 행의 dp값과 가장 왼 쪽 열의 dp값을 전처리해 두어야 한다. (이는 간단한 누적 합으로 가능)

<del> 좀 더 보편화 된 점화식을 만들어볼 수 있을 듯 한데 암튼 AC니 런 </del>
