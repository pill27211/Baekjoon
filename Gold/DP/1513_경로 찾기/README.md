
# [Gold II] 경로 찾기 - 1513

[문제 링크](https://www.acmicpc.net/problem/1513)

### 문제 요약

<p> 오락실을 0 ~ K번 방문해서 (1, 1) -> (n, m)에 도착하는 경로의 경우의 수를 각각 모두 구해보자.  </p>

### 제한

TL : 2sec, ML : 128 MB

1 ≤ n, m ≤ 50

0 ≤ k ≤ 50

### 성능 요약

메모리: 28456 KB, 시간: 80 ms

### 분류

다이나믹 프로그래밍(dp)

### comment

0 ~ k에 대한 답을 구해야 하고, 오락실을 오름차순으로만 방문할 수 있다.

단순히 k_x 번 방문했을 때의 경우의 수만을 메모이제이션 한다면, 그 경우를 포함 시켰을 때 오름차순으로 오락실을 방문 했는지 장담할 수 없다.

따라서 마지막으로 방문했던 오락실이 메모이제이션에 고려되어야만 한다. 이에 따라 다음과같이 dp테이블에 대한 정의를 내리자.

dp[i][j][k][o] : o번 오락실을 마지막으로 방문하였을 때, k번 오락실을 방문해 (i, j) -> (n, m)에 도착하는 경우의 수

--------------------------------------------------------------------------------------------------------------------------------------------

인자 4개(y좌표, x좌표, k : 남은 방문해야 하는 오락실 수, o : 마지막으로 방문한 오락실의 번호)를 들고 탑다운 방식으로 진행해보자.

우선 호출 흐름은 어떻게 진행 되어야 할까 ?

현재 방문한 곳에 오락실이 있을 때 || 없을 때로 나눠보자. (각각 ↓, → 에 대한 경우를 더해줌)

* 있을 때

->  현재 방문한 곳의 오락실 번호가 마지막으로 방문한 오락실 번호보다 커야 하며, k가 0보다 커야 한다.

이를 그대로 조건 식으로 옮겨주자. (if (a[p][q] > o && k > 0))

* 없을 때

-> 그대로 좌표상 위치만 옮겨주면 된다.

--------------------------------------------------------------------------------------------------------------------------------------------

그럼 이제 기저 조건은 어떻게 잡아야 할까 ?

일단 p == n && q == m 일 때로 잡는 건 확실하다.

그러나 문제에서도 언급되어 있듯이 (n, m)에 오락실이 있는 경우 || 없는 경우에 대해 조건을 잡아야 한다.

* 있을 때

-> 있다면 엄연히 오락실 방문횟수로 쳐야 하니 우선 k가 정확히 1 이어야 한다. 또한, 마지막으로 방문한 오락실 번호보다 커야 한다.

* 없을 때

-> 오락실을 k번 방문하는 경우를 계산해야 하니 k가 정확히 0이 되어 있어야 한다.

위 흐름을 그대로 코드로 옮겨주고 문제에서 주어지는 k = 0, 1, 2, ... 에 대해 각각 답을 출력해주면 끝.
